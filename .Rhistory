library(readxl)
datos <- read_excel("Datos_Quinua.xlsx")
View(datos)
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(agricolae)
library(ggplot2)
library(psych)  # para describe()
# 1) Leer datos
# Asume que guardaste el CSV con el encabezado exactamente como lo pegaste: "quinoa.csv"
datos <- read_excel("Datos_Quinua.xlsx")
# 2) Funciones auxiliares para parsear rangos "min-max" o valores únicos
parse_range_min <- function(x) {
x <- as.character(x)
x <- ifelse(is.na(x), NA, x)
# eliminar espacios
x <- str_trim(x)
# si contiene guion, tomar la parte antes como min
has_range <- str_detect(x, "-")
out <- rep(NA_real_, length(x))
# casos con rango: "a-b"
idx <- which(has_range)
if (length(idx)>0) {
parts <- str_split(x[idx], "-", simplify = TRUE)
out[idx] <- as.numeric(str_replace_all(parts[,1], "[^0-9\\.]", ""))
}
# casos sin rango: tomar el número entero/decimal
idx2 <- which(!has_range & !is.na(x) & x!="")
if (length(idx2)>0) {
out[idx2] <- as.numeric(str_replace_all(x[idx2], "[^0-9\\.]", ""))
}
return(out)
}
parse_range_max <- function(x) {
x <- as.character(x)
x <- ifelse(is.na(x), NA, x)
x <- str_trim(x)
has_range <- str_detect(x, "-")
out <- rep(NA_real_, length(x))
idx <- which(has_range)
if (length(idx)>0) {
parts <- str_split(x[idx], "-", simplify = TRUE)
out[idx] <- as.numeric(str_replace_all(parts[,2], "[^0-9\\.]", ""))
}
idx2 <- which(!has_range & !is.na(x) & x!="")
if (length(idx2)>0) {
out[idx2] <- as.numeric(str_replace_all(x[idx2], "[^0-9\\.]", ""))
}
return(out)
}
parse_range_mean <- function(x) {
mn <- parse_range_min(x)
mx <- parse_range_max(x)
# si ambos NA => NA; si mx < mn (por como esté escrito) => intercambiar
idx_swap <- which(!is.na(mn) & !is.na(mx) & mx < mn)
if (length(idx_swap)>0) {
tmp <- mn[idx_swap]; mn[idx_swap] <- mx[idx_swap]; mx[idx_swap] <- tmp
}
out <- rowMeans(cbind(mn, mx), na.rm = TRUE)
# si ambos NA, out=NaN -> convertir a NA_real_
out[is.nan(out)] <- NA_real_
return(out)
}
df2 <- df %>%
mutate(
# altitud media
Altitud_Mean_msnm = rowMeans(select(., Altitud_Min_msnm, Altitud_Max_msnm), na.rm = TRUE),
# transformar rangos escritos con guion a min/max/mean
pH_min = parse_range_min(pH_Suelo_Optimo),
pH_max = parse_range_max(pH_Suelo_Optimo),
pH_mean = parse_range_mean(pH_Suelo_Optimo),
Precipit_min = parse_range_min(Precipitacion_mm_año),
Precipit_max = parse_range_max(Precipitacion_mm_año),
Precipit_mean = parse_range_mean(Precipitacion_mm_año),
Densidad_min = parse_range_min(Densidad_Siembra_kg_ha),
Densidad_max = parse_range_max(Densidad_Siembra_kg_ha),
Densidad_mean = parse_range_mean(Densidad_Siembra_kg_ha),
DistSurcos_min = parse_range_min(Distancia_Surcos_cm),
DistSurcos_max = parse_range_max(Distancia_Surcos_cm),
DistSurcos_mean = parse_range_mean(Distancia_Surcos_cm),
Fert_N_min = parse_range_min(Fertilizacion_N_kg_ha),
Fert_N_max = parse_range_max(Fertilizacion_N_kg_ha),
Fert_N_mean = parse_range_mean(Fertilizacion_N_kg_ha),
Fert_P_min = parse_range_min(Fertilizacion_P2O5_kg_ha),
Fert_P_max = parse_range_max(Fertilizacion_P2O5_kg_ha),
Fert_P_mean = parse_range_mean(Fertilizacion_P2O5_kg_ha),
Fert_K_min = parse_range_min(Fertilizacion_K2O_kg_ha),
Fert_K_max = parse_range_max(Fertilizacion_K2O_kg_ha),
Fert_K_mean = parse_range_mean(Fertilizacion_K2O_kg_ha),
Cont_Humedad_min = parse_range_min(Contenido_Humedad_Cosecha),
Cont_Humedad_max = parse_range_max(Contenido_Humedad_Cosecha),
Cont_Humedad_mean = parse_range_mean(Contenido_Humedad_Cosecha),
# Transformar Rendimiento a valor medio
Rendimiento_mean = rowMeans(select(., Rendimiento_Min_kg_ha, Rendimiento_Max_kg_ha), na.rm = TRUE),
# Peso 1000 granos y Proteína ya deberían ser numéricos; forzar numeric seguro
Peso_1000_Gramos_g = as.numeric(Peso_1000_Granos_g),
Proteina_Porcentaje = as.numeric(Proteina_Porcentaje),
# Contenido_Saponina_Porcentaje numeric (ya aparece como 0.08 etc)
Cont_Saponina = as.numeric(Contenido_Saponina_Porcentaje),
# Ciclo_Dias -> numeric
Ciclo_Dias = as.numeric(Ciclo_Dias),
# Dias_Floracion/Dias_Maduracion numeric
Dias_Floracion = as.numeric(Dias_Floracion),
Dias_Maduracion = as.numeric(Dias_Maduracion),
# Año_Registro -> numeric si no tiene texto como 'Pre-inca' -> poner NA en esos casos
Año_Registro_num = suppressWarnings(as.numeric(Año_Registro)),
Año_Registro_num = ifelse(is.na(Año_Registro_num), NA_integer_, Año_Registro_num)
)
# 4) Normalizar/limpiar categorías: quitar espacios y uniformar factores
cols_cat <- c("Variedad","Color_Grano","Tipo_Ecotipo","Origen","Provincia","Distrito","Saponina",
"Resistencia_Helada","Resistencia_Sequia","Resistencia_Granizo",
"Susceptibilidad_Mildiu","Susceptibilidad_Kcona_Kcona","Color_Planta",
"Institucion","Uso_Principal","Textura_Suelo","Epoca_Siembra","Epoca_Cosecha","Observaciones")
for (c in cols_cat) {
if (c %in% names(df2)) {
df2[[c]] <- ifelse(is.na(df2[[c]]), NA, str_squish(as.character(df2[[c]])))
df2[[c]] <- as.factor(df2[[c]])
}
}
# 5) Crear una variable de tratamiento y otra para bloques
# Tratamiento: Variedad (tal cual); Bloques: sugerencia — usar cortes de altitud (3 bloques por ejemplo)
df2 <- df2 %>%
mutate(
Tratamiento = Variedad %>% as.character() %>% as.factor(),
Bloque_altitud = cut(Altitud_Mean_msnm,
breaks = quantile(Altitud_Mean_msnm, probs = c(0,0.33,0.66,1), na.rm = TRUE),
include.lowest = TRUE,
labels = c("Bajo","Medio","Alto"))
)
# 6) Comprobaciones rápidas / estadísticas descriptivas
cat("Dimensiones del dataset:", dim(df2), "\n\n")
cat("Resumen rápido de variables numéricas:\n")
print(describe(select(df2, where(is.numeric))))
cat("\nTabla de tratamientos (n por variedad):\n")
print(df2 %>% group_by(Tratamiento) %>% summarise(n = n(), Rend_prom = mean(Rendimiento_mean, na.rm = TRUE)) %>% arrange(desc(n)))
# 7) Preparar diseño experimental: ejemplo RCBD (bloques completos aleatorizados)
# Decisiones: número de repeticiones = número de bloques (aquí usamos Bloque_altitud si no NA)
# Observar cuántos bloques hay no-NA
bloques_exist <- df2 %>% filter(!is.na(Bloque_altitud)) %>% distinct(Bloque_altitud) %>% pull(Bloque_altitud)
cat("\nBloques detectados por altitud:", paste(bloques_exist, collapse = ", "), "\n")
# Si quieres un RCBD con tratamientos = variedades y bloques = altitud (si hay suficientes repeticiones)
# Pero para usar agricolae::design.rcbd se necesita el número de repeticiones (bloques) y número de tratamientos.
treatments <- levels(df2$Tratamiento)
ntr <- length(treatments)
# supongamos que queremos r = 3 repeticiones (uno por bloque de altitud)
r <- length(bloques_exist)
cat("Número tratamientos:", ntr, " — repeticiones solicitadas:", r, "\n")
# Generar asignación experimental (si r * ntr es aceptable; aquí generamos layout ficticio)
# Nota: Si ya tienes las variedades observadas y quieres asignarlas a parcelas físicas, usa design.rcbd
set.seed(123)
if (!is.na(r) & r >= 2) {
rcbd <- design.rcbd(trt = treatments, r = r, seed = 123, serie = 2)
layout_rcbd <- rcbd$book %>%
rename(Plot = plot, Bloque = block, Tratamiento = trt) %>%
mutate(Tratamiento = factor(Tratamiento, levels = treatments))
cat("\nEjemplo de asignación RCBD (primeras 12 filas):\n")
print(head(layout_rcbd, 12))
} else {
cat("No hay suficientes bloques detectados para crear un RCBD automático. Puedes especificar r (repeticiones) manualmente.\n")
}
# 8) Variables numéricas seleccionadas para análisis multivariante (PCA/cluster)
num_vars <- df2 %>%
select(Altitud_Min_msnm, Altitud_Max_msnm, Altitud_Mean_msnm,
Ciclo_Dias, Altura_Planta_cm, Diametro_Panoja_cm,
Rendimiento_Min_kg_ha, Rendimiento_Max_kg_ha, Rendimiento_mean,
Peso_1000_Gramos_g, Proteina_Porcentaje, Cont_Saponina,
Dias_Floracion, Dias_Maduracion, Cont_Humedad_mean = Cont_Humedad_mean) %>%
select(where(~ any(!is.na(.))))
# Imprimir correlaciones básicas
cat("\nCorrelaciones (primeras variables numéricas):\n")
print(cor(na.omit(num_vars), use = "pairwise.complete.obs")[1:6, 1:6])
# 9) Guardar dataset procesado
write_csv(df2, "quinoa_procesada_para_diseno.csv")
cat("\nArchivo guardado: quinoa_procesada_para_diseno.csv\n")
# 10) Opciones gráficas rápidas (ejemplos)
# Boxplot de rendimiento promedio por color de grano
ggplot(df2, aes(x = Color_Grano, y = Rendimiento_mean)) +
geom_boxplot() +
labs(title = "Rendimiento promedio por Color de Grano", x = "Color de grano", y = "Rendimiento (kg/ha)") +
theme_minimal()
# Scatter Altitud vs Rendimiento
ggplot(df2, aes(x = Altitud_Mean_msnm, y = Rendimiento_mean, label = Variedad)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Altitud media vs Rendimiento promedio", x = "Altitud (msnm)", y = "Rendimiento (kg/ha)") +
theme_minimal()
# 11) Notas / recomendaciones
cat("\nNOTAS:\n")
cat(" - Revisa manualmente las filas con 'Año_Registro' no numérico (p.ej 'Pre-inca').\n")
cat(" - Si quieres usar Provincia como bloque, sustituye Bloque_altitud por Provincia y genera el diseño con agricolae.\n")
cat(" - Si vas a analizar rendimiento, define claramente la variable respuesta (Rendimiento_mean o rendimiento medido in-situ).\n")
cat(" - Para ANOVA en RCBD: usa aov(Respuesta ~ Tratamiento + Bloque, data = datos_experimentales).\n")
# ============================================
# 1) Cargar librerías
# ============================================
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(agricolae)
# ============================================
# 2) Leer datos
# ============================================
df <- read_excel("Datos_Quinua.xlsx")
# ============================================
# 3) Funciones simples para leer rangos "min-max"
# ============================================
extraer_min <- function(x){
x <- as.character(x)
x <- str_trim(x)
ifelse(str_detect(x, "-"),
as.numeric(str_extract(x, "^[0-9\\.]+")),
as.numeric(x))
}
extraer_max <- function(x){
x <- as.character(x)
x <- str_trim(x)
ifelse(str_detect(x, "-"),
as.numeric(str_extract(x, "(?<=-)[0-9\\.]+")),
as.numeric(x))
}
extraer_media <- function(x){
a <- extraer_min(x)
b <- extraer_max(x)
rowMeans(cbind(a,b), na.rm = TRUE)
}
# ============================================
# 4) Crear df2 con variables limpias
# ============================================
df2 <- df %>%
mutate(
pH_min    = extraer_min(pH_Suelo_Optimo),
pH_max    = extraer_max(pH_Suelo_Optimo),
pH_mean   = extraer_media(pH_Suelo_Optimo),
Precipit_min  = extraer_min(Precipitacion_mm_año),
Precipit_max  = extraer_max(Precipitacion_mm_año),
Precipit_mean = extraer_media(Precipitacion_mm_año),
Rendimiento_mean = rowMeans(cbind(Rendimiento_Min_kg_ha,
Rendimiento_Max_kg_ha), na.rm = TRUE)
)
# ============================================
# 5) Limpiar variables categóricas
# ============================================
cols_cat <- c("Variedad","Color_Grano","Tipo_Ecotipo","Provincia","Distrito")
for(c in cols_cat){
if(c %in% names(df2)){
df2[[c]] <- df2[[c]] %>%
as.character() %>%
str_squish() %>%
as.factor()
}
}
# ============================================
# 6) Crear un diseño experimental SIMPLE (RCBD)
# Tratamientos = variedades
# Bloques = 3 (Bajo, Medio, Alto) según altitud
# ============================================
# Crear una variable de altitud media solo si existe
if("Altitud_Min_msnm" %in% names(df2) & "Altitud_Max_msnm" %in% names(df2)){
df2 <- df2 %>%
mutate(Altitud_Mean = (Altitud_Min_msnm + Altitud_Max_msnm)/2)
}
# Bloques por terciles de altitud
df2 <- df2 %>%
mutate(
Bloque = cut(Altitud_Mean,
breaks = quantile(Altitud_Mean, probs = c(0,0.33,0.66,1), na.rm = TRUE),
labels = c("Bajo","Medio","Alto"),
include.lowest = TRUE)
)
# Diseño experimental (ficticio, solo asignación)
trat <- levels(df2$Variedad)
r <- 3  # 3 bloques
rcbd <- design.rcbd(
trt = trat,
r = r,
seed = 123,
serie = 2
)
layout_rcbd <- rcbd$book
print(head(layout_rcbd, 12))
# ============================================
# 1) Cargar librerías
# ============================================
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(agricolae)
# ============================================
# 2) Leer datos
# ============================================
df <- read_excel("Datos_Quinua.xlsx")
head(df)
str(df)
head(df)
str(df)
